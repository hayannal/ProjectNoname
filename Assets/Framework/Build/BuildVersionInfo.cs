using UnityEngine;

[CreateAssetMenu(fileName = "NewBuildVersionInfo", menuName = "CustomAsset/Create BuildVersionInfo", order = 1100)]
public class BuildVersionInfo : ScriptableObject
{
	// Application.version 의 값이 플랫폼 상관없이 공용이라는 점때문에 관리상 문제가 심했다.
	// 하필 공용이다보니 안드로 맞춰두고 iOS에서는 커밋하지 않은채 써야하는데
	// 깃은 수정중인 파일은 받기전에 꼭 리버트 시키기때문에 버전값을 덮어써두면 iOS에서는 업뎃을 받을 수 없게된다.
	// 그렇다고 받을때마다 옆에다가 기록해놓고 받은담에 도로 머지하기엔 너무 불편하다.
	// 게다가 생각해보니 이 version은 구글 플레이나 앱스토어 다운로드 페이지에 나오는데 리젝때문에 증가된 번호가 노출되는게 맞는건가 싶다.
	// 그래서 아예 구조를 바꾸기로 했다.
	//
	// 1. Application.version은 구글이나 앱스토어 다운로드 페이지에 나오는 만큼 아예 공용으로 간다.
	// 이건 정식 런칭 1.0부터 시작해서 큰 업데이트때마다 0.1 늘어나는 구조다.(원신처럼) 캐릭터 추가나 무기 추가하는 단계에선 하지 않는다.
	//
	// 2. 프로그램에서 코드로 얻을 수 없는 안드로이드 빌드번호나 iOS 빌드번호는 진짜 제출을 위해 1 증가시키는 용도로만 쓴다.
	// 이건 리젝 등의 이유에 의해 플랫폼별로 완전히 다를 수 있다. 유저에게는 노출하지 않는다.
	//
	// 3. 진짜로 스토어로 이동되는 버전확인용을 위해 별도의 숫자를 입력할 수 있게 한다.
	// 당연히 플랫폼별로 따로 만들며 리젝이 되어도 증가시키진 않으나 유저에게 배포된 빌드에 문제가 있어서 마켓 업데이트를 유도할때는 증가시켜야한다.
	// 이건 서버에 적어둔 버전과 비교해서 낮으면 마켓에 들어가라고 알린다. 숫자 자체는 유저한테 노출하지 않는다.
	// 이 값을 기록해두는게 이 updateVersion이다.
	public int updateVersion;
	// 서버에 있는 값과 비교하기 때문에 비교할 키 이름을 적어두고 사용.
	// 플레이팹에다가는 upVrAnd / upVrIph 이런식으로 추가한다.
	public string serverKeyName;


	// 4. 어드레서블 버킷의 번호를 적어두고 기록하는 용도다.
	// 딱히 노출되지도 않고 코드안에서 불러다 쓰진 않지만 이 빌드가 어느 버킷을 바라보는지 판단하기 위한거로 기록해둔다.
	public int addressableVersion;







	///////////////////////////////////////////////////////////////////////////////////////////////
	// 과거 Application.version 으로 관리하려고 했던거에 대한 기록을 아래 남겨둔다.
	// 플랫폼마다 따로였으면 그나마 했을텐데 불편해서 패스한 방식이다.
	//
	// 흔히 사용하는 버전 권장 표기가 메이저.마이너.빌드 표기이지만
	// 이걸 따르지 않고 제일 앞 번호를 시즌 번호로 가운데 번호를 업데이트 구분 번호로 마지막 번호를 리소스 번호로 쓰려고 했었다.(이렇게 썼었는데 단점이 있어서 버린거다.)
	// 예를 들어 1.15.4 하면 15번 빌드고
	// 서버에서 받은 업데이트 빌드 번호가 16이면 패치하라고 뜨는 구조다.
	// 이 번호는 사실 Bundle Code Number랑은 달라질 수 있는데
	// 이 코드는 마켓에 올릴때 무조건 증가시켜야하는 코드라서 올릴때마다 1씩 증가시킬거고, 리젝같은 이유로 다시 올릴때마다 1씩 올라갈텐데
	// 아직 유저에게 배포되기 전이라면 빌드번호는 그대로 유지해도 된다.
	// 어차피 유저에게 배포된 버전보다만 1 높으면 업데이트가 뜨기 때문.
	// 
	// 리소스 패치 번호는 맨 뒷번호를 쓸거다. 위에서라면 4번 리소스다. 빌드를 묶을때 Remote Path에다가 그에 맞는 Badge 주소를 입력해놨을테니
	// 거기에다가 해당 번들들을 넣어두면 될거다.
	// 심사 빌드를 위해서는 새 Badge 주소를 받아다 적용 후 새 빌드를 뽑으면 그 빌드는 새 Badge를 바라보게 될것이니
	// 유저들이 빌드 업뎃을 하면 알아서 새 Badge에서 데이터를 긁어와 비교할 것이다.
	// 
	// 테이블 패치만 하는 경우가 문제인데,
	// 이럴땐 새 Badge를 발급 받는게 아니라 원래 연결된 Badge에다가 업데이트된 테이블을 밀어넣으면
	// 클라가 실행시에 비교 후 업뎃이 있다고 띄우는 형태인거다.
	// 이걸 위해 Badge를 구분하기 편해야하니 Badge이름에다가 저 리소스 패치 번호를 붙여두는게 구분할때 편할거다.
	//Debug.LogFormat("Application version = {0}", Application.version);
	//string[] split = Application.version.Split('.');
	//if (split.Length != 3)
	//{
	//	// 관리되지 않는 버전 번호다. 패스.
	//	return true;
	//}
}